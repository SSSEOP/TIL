# Index
- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터베이스 객체
- 인덱스를 통해서 레코드에 대한 액세스를 빠르게 수행할 수 있음
- 대부분의 `DBMS`에서는 기본키에 대해서 자동적으로 기본 인덱스를 생성
- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적
- 인덱스가 없을경우 특정 값을 찾기 위해 `Full Scan` 발생
- WHERE절에서 효과가 있음
    - `Index`가 걸려있는 필드를 `WHERE`절에서 사용했을 때 효율 향상
- 인덱스 효율은 조회시 자주 사용하고 고유한 값을 가진 필드가 좋음

## 단점
- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음
- 인덱스를 많이 만들면 오버헤드가 발생
- 넓은 범위를 인덱스로 처리하면 많은 오버헤드가 발생
- 인덱스를 만들면 추가적인 저장 공간이 필요

## 인덱스 설정 기준
- ### Cardinality
    - 카디널리티가 높을 수록 인덱스 효율이 좋음
    - 즉, 중복도가 낮아야 인덱스 효율이 좋음
- ### Selectivity
    - `선택도 = 조회하는 row / 테이블의 총 row * 100` 
    - 선택도가 낮을 수록 인덱스 효율이 좋음(5~10%가 적당)
- ### 활용도
    - 활용도가 높을 수록 인덱스 효율이 좋음
    - 쿼리를 날릴 때 `WHERE`절에 자주 사용되는지 여부

## 인덱스 저장 방식
### Clustered Index
- 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있음
- 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬 해야함
- 한 개의 릴레이션에 하나의 인덱스만 생성 가능
### Non-Clustered Index
- 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
- 데이터를 검색하기 위해서 먼저 인덱스를 검색하여 실제 데이터의 위치를 확인해야하므로 클러스터드 인덱스에 비해 검색 속도가 떨어짐
- 한 개의 릴레이션에 여러개의 인덱스를 만들 수 있음
