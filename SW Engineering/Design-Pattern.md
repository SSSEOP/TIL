# Design Pattern
---------------
## 디자인 패턴이란?
- 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 재발했을 때 재사용할 수 있는 해결책

## 디자인 패턴 구조
- ### 콘텍스트(Context)
  - 문제가 발생하는 여러 상황을 기술, 즉 패턴이 적용될 수 있는 상황을 나타냄
  - 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도함
- ### 문제(Problem)
  - 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술
  - 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야함
- ### 해결(Solution)
  - 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술
  - 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿

## 디자인 패턴 종류
- GoF라고 불리는 에리히 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스가 23가지로 정리하고 생성, 구조, 행위의 3가지로 분류함
1. 생성 패턴(Creation Pattern)
  - 객체 생성(변경)에 관련된 패턴
  - 객체가 생성 되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공
  - 종류
    - 추상 팩토리(Abstract Factory) : 구체적인 클래스를 지정하지 않고 관련성이 있거나 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴
    - 싱글톤(Singleton) : 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴
    - 빌더(Builder) : 복합 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴
    - 팩토리 메서드(Factory Method) : 객체를 생성하는 인터페이스를 정의하지만 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴
    - 프로토타입(Prototype) : 생성할 객체의 종류를 명시하는데 원형이 되는 예시물을 이용하고 새로운 객체에 원형들을 복사함으로써 생성하는 패턴

2. 구조 패턴(Structual Pattern)
  - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
  - 서로다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴
  - 종류
    - 어댑터(Adapter) : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함계 작동하도록 해주는 패턴
    - 브릿지(Bridge) : 구현부에서 추상층을 분리해서 각자 독립적으로 변형할 수 있는 패턴
    - 컴퍼지트(Composite) : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로 사용자가 단일/복합객체 모두 동일하게 다루도록 해주는 패턴
    - 데커레이터(Decorator) : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로 기능확장이 필요할 때 서브 클래스 대신 쓸 수 있는 대안이 되는 패턴
    - 퍼사드(Facade) : 서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공하고 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의
    - 프록시(Proxy) : 어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴
    - 플라이웨이트(Flyweight)

3. 행위 패턴(Behavioral Pattern)
  - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
  - 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지와 그러게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점
  - 종류
    - 책임 연쇄(Chain of Responsibility) : 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달
    - 커맨드(Command) : 요청을 객체로 캡슐화하여 여러 기능을 실행할 수 있는 재사용성이 높은 클래스로 설계하는 패턴
    - 인터프리터(Interpreter) : 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴
    - 이터레이터(Iterator) : 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴
    - 미디에이터(Meditator) : 모든 클래스간의 복잡한 로직을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴
    - 옵저버(Observer) : 객체들 사이에 1:N의 의존관계를 정의하여 어떤 객체의 상태가 변할 때 의존관계에 있는 모든 객체들이 통지받고 자동으로 갱신할 수 있는 패턴
    - 스테이트(State) : 객체의 상태에 따라서 각각의 다른 행위를 할 수 있도록 캡슐화한 패턴
    - 스트래티지(Strategy) : 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있는 패턴
    - 템플릿 메서드(Template Method) : 객체의 연산에서 알고리즘의 뼈대만 정의하고 나머지는 서브클래스에서 이루어지도록 하는 패턴
    - 비지터(Visitor) : 객체의 구조와 기능을 분리시키는 패턴으로 구조는 변하지 않으면서 기능만 따로 추가하거나 확장해야할 경우에 사용
    - 메멘토(Memento)