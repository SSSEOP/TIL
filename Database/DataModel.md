# Data Model
- 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형
- 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약조건 등을 기술하기 위한 개념적 도구들의 모임
- 데이터베이스 설계 과정에서 데이터의 구조를 논리적으로 표현하기 위해 사용되는 지능적 도구

## 구성 요소
- ### 개체(Entity)
    - 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
- ### 속성(Attribute)
    - 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
- ### 관계(Relationship)
    - 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미

## 개념적 데이터 모델
- 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
- 개념적 데이터 모델은 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실세계를 표현
- 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도함
- 대표적인 개념적 데이터 모델은 `E-R 모델`

## 논리적 데이터 모델
- 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
- 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현
- 특정 `DBMS`는 특정 논리적 데이터 모델 하나만 선정하여 사용
- 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분

### 논리적 데이터 모델의 품질 검증
- 개체 품질 검증
- 속성 품질 검증
- 관계 품질 검증
- 식별자 품질 검증
- 전반적인 품질 검증

## 데이터 모델에 표시할 요소
- ### 구조(Structure)
    - 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
- ### 연산(Operation)
    - 데이터베이스에 저장된 실제 데이터를 처리하는 작업에대한 명세로서 데이터베이스를 조작하는 기본 도구
- ### 제약조건(Constraint)
    - 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 논리 데이터 모델 -> 물리 데이터 모델 변환
### 테이블
- 테이블은 데이터를 저장하는 데이터베이스의 가장 기본적인 오브젝트
#### 테이블의 구성요소
- 로우(Row)
    - 튜플, 인스턴스, 어커런스라고도함
- 컬럼(Column)
    - 각 속성 항목에 대한 값을 저장
- 기본키(Primary Key)
    - 기본키는 후보키 중에서 선택한 주키
    - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
- 외래키(Foreign Key)
    - 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
    - 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의 되었을 때의 속성 A를 외래키라고함

### 엔티티 -> 테이블 변환
- 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환
- 엔티티를 테이블로 변환한 후 테이블 목록 정의서 작성
    - 테이블 목록 정의서 : 전체 테이블을 목록으로 요약 관리하는 문서로, 테이블 목록이라고도함

#### 변환 규칙
- 엔티티 -> 테이블
- 속성 -> 컬럼
- 주 식별자 -> 기본키
- 외부 식별자 -> 외래키
- 관계 -> 관계

#### 변환시 고려사항
- 일반적으로 테이블과 엔티티 명칭은 동일하게 하는 것을 권고
- 엔티티는 주로 한글명을 사용하지만 테이블은 소스 코드의 가독성을 위해 영문명 사용
- 메타 데이터 관리 시스템에 표준화된 용어가 있을 때는 메타에 등록된 단어를 사용하여 명명

### 슈퍼타입/서브타입 -> 테이블 변환
#### 슈퍼타입 기준 테이블 변환
- 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것
- 장점
    - 데이터의 액세스가 상대적으로 용이
    - 뷰를 이용하여 각각의 서브타입만을 액세스하거나 수정할 수 있음
    - 서브타입 구분이 없는 임의 집합에 대한 처리가 용이
    - 여러 테이블을 조인하지 않아도 되므로 수행 속도가 빠름
    - SQL 문장 구성이 단순해짐
- 단점
    - 테이블의 컬럼수가 증가하므로 디스크 저장 공간이 증가
    - 처리마다 서브타입에 대한 구분이 필요한 경우가 발생
    - 인덱스 크기의 증가로 인덱스의 효율이 떨어짐

#### 서브타입 기준 테이블 변환
- 슈퍼타입의 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것
- 장점
    - 각 서브타입 속성들의 선택 사양이 명확한 경우에 유리
    - 처리할 때마다 서브타입 유형을 구분할 필요 없음
    - 여러 개의 테이블로 통합하므로 테이블당 크기가 감소하여 전체 테이블 스캔시 유리
- 단점
    - 수행 속도가 비교적 느림
    - 복잡한 처리를 하는 SQL의 통합이 어려움
    - 부분 범위에 대한 처리가 곤란
    - 여러 테이블을 통합한 뷰는 조회만 가능
    - UID의 유지 관리가 어려움

#### 개별타입 기준 테이블 변환
- 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것
- 장점
    - 저장 공간이 상대적으로 작음
    - 슈퍼타입 또는 서브타입 각각의 테이블에 속한 정보만 조회하는 경우 문장 작성이 용이
- 단점
    - 슈퍼타입 또는 서브타입의 정보를 같이 처리하면 항상 조인이 발생하여 성능이 저하됨

### 속성 -> 컬럼 변환
- 일반 속성 변환
- Primary UID를 기본키로 변환
- Primary UID(관계의 UID Bar)를 기본키로 변환
- Secondary UID를 유니크 키로 변환

### 관계 -> 외래키 변환
#### 1:1 관계
- 개체 A의 기본키를 개체 B의 외래키로 추가

#### N:M 관계
- 릴레이션 A와 B의 기본키를 모두 포함한 별도의 릴레이션으로 표현
- 생성된 별도의 릴레이션은 교차 릴레이션 또는 교차 엔티티라고 부름

#### 1:M 순환 관계
- 개체 A에 개체 A의 기본키를 참조하는 외래키 컬럼을 추가하여 표현
- 데이터의 계층 구조를 표현하기 위해 주로 사용